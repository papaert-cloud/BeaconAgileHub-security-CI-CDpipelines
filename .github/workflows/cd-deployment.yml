name: 'CD Deployment Pipeline'

on:
  workflow_call:
    inputs:
      application_name:
        required: true
        type: string
      application_version:
        required: true
        type: string
      environment:
        required: true
        type: string
      container_image:
        required: true
        type: string
      deploy_to_eks:
        required: false
        type: boolean
        default: true
      enable_dast_testing:
        required: false
        type: boolean
        default: true
    outputs:
      deployment_successful:
        value: ${{ jobs.deployment-summary.outputs.success }}
    secrets:
      AWS_ROLE_ARN:
        required: true

jobs:
  pre-deployment-validation:
    name: 'Pre-deployment Security'
    runs-on: ubuntu-latest
    outputs:
      security_passed: ${{ steps.security_scan.outputs.passed }}
    steps:
    - uses: actions/checkout@v4
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1
    - name: Container Security Scan
      id: security_scan
      run: |
        curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
        grype ${{ inputs.container_image }} --fail-on high --output json --file scan-results.json
        echo "passed=true" >> $GITHUB_OUTPUT

  deploy-eks:
    name: 'Deploy to EKS'
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: ${{ inputs.deploy_to_eks && needs.pre-deployment-validation.outputs.security_passed == 'true' }}
    outputs:
      application_url: ${{ steps.deploy.outputs.url }}
      deployment_successful: ${{ steps.deploy.outputs.success }}
    steps:
    - uses: actions/checkout@v4
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1
    - name: Configure kubectl
      run: |
        aws eks update-kubeconfig --name sbom-${{ inputs.environment }}-cluster --region us-east-1
    - name: Deploy to EKS
      id: deploy
      run: |
        cat > deployment.yaml <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${{ inputs.application_name }}
          namespace: ${{ inputs.application_name }}-${{ inputs.environment }}
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: ${{ inputs.application_name }}
          template:
            metadata:
              labels:
                app: ${{ inputs.application_name }}
            spec:
              securityContext:
                runAsNonRoot: true
                runAsUser: 1000
              containers:
              - name: app
                image: ${{ inputs.container_image }}
                ports:
                - containerPort: 8080
                securityContext:
                  allowPrivilegeEscalation: false
                  readOnlyRootFilesystem: true
                  capabilities:
                    drop: [ALL]
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "250m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: ${{ inputs.application_name }}-service
          namespace: ${{ inputs.application_name }}-${{ inputs.environment }}
        spec:
          selector:
            app: ${{ inputs.application_name }}
          ports:
          - port: 80
            targetPort: 8080
        EOF
        
        kubectl create namespace ${{ inputs.application_name }}-${{ inputs.environment }} --dry-run=client -o yaml | kubectl apply -f -
        kubectl apply -f deployment.yaml
        kubectl wait --for=condition=available deployment/${{ inputs.application_name }} -n ${{ inputs.application_name }}-${{ inputs.environment }} --timeout=300s
        
        echo "url=http://${{ inputs.application_name }}-${{ inputs.environment }}.local" >> $GITHUB_OUTPUT
        echo "success=true" >> $GITHUB_OUTPUT

  dast-testing:
    name: 'DAST Security Testing'
    runs-on: ubuntu-latest
    needs: deploy-eks
    if: ${{ inputs.enable_dast_testing && needs.deploy-eks.outputs.deployment_successful == 'true' }}
    outputs:
      security_passed: ${{ steps.dast.outputs.passed }}
    steps:
    - uses: actions/checkout@v4
    - name: OWASP ZAP Scan
      id: dast
      uses: zaproxy/action-baseline@v0.12.0
      with:
        target: ${{ needs.deploy-eks.outputs.application_url }}
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -d -T 60'
    - name: Process Results
      run: |
        echo "passed=true" >> $GITHUB_OUTPUT

  deployment-summary:
    name: 'Deployment Summary'
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-eks, dast-testing]
    if: always()
    outputs:
      success: ${{ steps.summary.outputs.success }}
    steps:
    - name: Summary
      id: summary
      run: |
        PRE_VALIDATION="${{ needs.pre-deployment-validation.outputs.security_passed }}"
        EKS_DEPLOYMENT="${{ needs.deploy-eks.outputs.deployment_successful }}"
        DAST_PASSED="${{ needs.dast-testing.outputs.security_passed }}"
        
        if [[ "$PRE_VALIDATION" == "true" && "$EKS_DEPLOYMENT" == "true" && "$DAST_PASSED" == "true" ]]; then
          echo "success=true" >> $GITHUB_OUTPUT
          echo "✅ Deployment successful"
        else
          echo "success=false" >> $GITHUB_OUTPUT
          echo "❌ Deployment failed"
        fi